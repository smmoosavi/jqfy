jQfy
====
[![npm version][npm:version]](https://www.npmjs.org/package/jqfy)

Complies in server, Render in browser. [online demo](http://smmoosavi.github.io/jqfy/demo)

Install
-------

```
$ npm install -g jqfy
```

Usage
-----

Complie htmls

```
$ mkdir templates/
$ vim templates/well.html # write your sub html
$ jqfy -i templates/ -o js/templates.js
```

Use in browser:
 
```html
<script src="js/jquery.min.js"></script>
<script src="js/templates.js"></script>
<script>
    $('body').append(templates.well())
</script>
```

help
----

```
$ jqfy -h
 
   Usage: jqfy [options]
 
   Options:
 
     -h, --help                   output usage information
     -V, --version                output the version number
     -i, --input [path]           source file or directory (default: .)
     -o, --output [path]          destination file
     -r, --return-type [type]     choice return type (root|contents|html)
     -e, --ext [ext]              extensions (default: html)
     -n, --namespace [namespace]  namespace (default: templates)
     -T, --no-trim                do not trim
     -C, --no-comment             ignore comments
 

```

Api
---

### jqfy.compile(html, [opts])

#### arguments: 

* `html`: string
* `opts`: object
 * `name`: string|array 
 * `returnType`: string, (contents|html|root), default: contents 
 * `trim`: boolean, default true
 * `comment`: boolean, default true

**html**: input html

**name**: name of generated function as string or array. when you are use nested name, this better to use array.

**returnType**: default return type of generated function.

**trim**: remove white unnecessary white spaces.

**comment**: keep html comments.

#### return

code of generated function

### jqfy.append(html, [opts])

like compile, but save code in memory

### jqfy.getCode([name])

get in memory generated code with [umd][umd]

#### arguments

* `name`: string, default `templates`. name for umd module

### jqfy.flush()

remove in memory codes

Example
-------
```js
var html = '<div class="text-success">jQfy</div>';
html += '<script>console.log("jQfy");</script>';
var jqfy = require('jqfy');
var code = jqfy.compile(html);
console.log(code);
```

output:

```js
function (data, opts) {
    // generated by jQfy 1.3.0
    opts = $.extend({}, opts);
    data = $.extend({}, data);
    var $root = $('<div/>');
    
    var $div1 = $('<div/>')
        .addClass("text-success")
        .appendTo($root);
    $div1.append(document.createTextNode("jQfy"));
    //  end $div1
    
    // start script 1
    console.log("jQfy");
    //  end script 1
    
    // end $root
    var output = null;
    switch (opts.returnType) {
        case "html":
            output = $root.html();
            break;
        case "root":
            output = $root;
            break;
        case "contents":
        case "children":
            // children will be removed in version 2.*
            output = $root.contents();
            break;
        default :
            output = $root.contents();
    }
    return output;
}
```

How it works
------------

First we parse your html with [cheerio][cheerio] then foreach tag generate a code. This code create a jquery object
and set id, class and attributes of element, then append jquery object to parent's jquery object. if script tags exist
in your html, we append content of script to generated code.

[npm:version]: http://img.shields.io/npm/v/jqfy.svg "npm"
[TODO:not-implemented]: http://img.shields.io/badge/TODO-not%20implemented-yellow.svg "not implemented"
[umd]: https://github.com/umdjs/umd "umd"
[cheerio]: https://github.com/cheeriojs/cheerio "Cheerio"